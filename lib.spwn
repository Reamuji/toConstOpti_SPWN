extract obj_props
extract $
return{
    toConstOpti : (
        counter : @counter,
        range : @range,
        trig : @object,
        key:@object_key
    ){
        rangeSize = abs(range.end - range.start)
        binaryDigit = ceil(log(rangeSize,2))

        zero = 0
        one  = 1
//      for grouping the trigger | digit[<digit number>][one/zero]
        // let groups = [?g for i in 0..(2 * binaryDigit)]
        let digit = [[?g for i in 0..2] for j in 0..binaryDigit]
        print(digit)

        for i in range{
            let group = []
            let k = i 
            for j in binaryDigit..0{
                if k >= 2^j {
                    k -= 2^j
                    group.push(digit[j][one])
                }else{
                    group.push(digit[j][zero])
                }
            }

            let trig = trig
            trig.set(SPAWN_TRIGGERED,true)
            trig.set(GROUPS,group)
            trig.set(Y,2160)
            trig.set(key,i)
            add(trig)
        }
        return !{
            for j in binaryDigit..1{
                -> if counter < 2^j {
                    digit[j][one].toggle_off()
                }else{
                    counter -= 2^j 
                    digit[j][zero].toggle_off()
                    wait(0.01)
                    counter += 2^j 
                    digit[j][zero].toggle_on()
                }
            }
            -> if counter > 0 {
                digit[0][one]!
            }else{
                digit[0][zero]!
            }
        }
    },

    
    toConstOptiAdv : (
        counter : @counter,
        range   : @range|[@number],
        trig    : @object,
        key     : @object_key,
        modifier: @macro = (n)=>n,
    ){
        rangeSize = abs(range.end - range.start)
        binaryDigit = ceil(log(rangeSize,2))

        zero = 0
        one  = 1
//      for group for the trigger | digit[<digit number>][one/zero]
        let digit = [[?g for i in 0..2] for j in 0..binaryDigit]
        print(digit)

        for i in range{
            let group = []
            let k = i 
            for j in binaryDigit..0{
                if k >= 2^j {
                    k -= 2^j
                    group.push(digit[j][one])
                }else{
                    group.push(digit[j][zero])
                }
            }

            let trig = trig
            trig.set(SPAWN_TRIGGERED,true)
            trig.set(GROUPS,group)
            trig.set(Y,2160)
            trig.set(key,modifier(i))
            add(trig)
        }
        return !{
            for j in binaryDigit..1{
                -> if counter < 2^j {
                    digit[j][one].toggle_off()
                }else{
                    counter -= 2^j 
                    digit[j][zero].toggle_off()
                    wait(0.01)
                    counter += 2^j 
                    digit[j][zero].toggle_on()
                }
            }
            -> if counter > 0 {
                digit[0][one]!
            }else{
                digit[0][zero]!
            }
        }
    }
}